// Package LifeService comment
// This file was generated by tars2go 1.1.4
// Generated from DataService.tars
package LifeService

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/TarsCloud/TarsGo/tars"
	m "github.com/TarsCloud/TarsGo/tars/model"
	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
	"github.com/TarsCloud/TarsGo/tars/protocol/res/basef"
	"github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	"github.com/TarsCloud/TarsGo/tars/protocol/tup"
	"github.com/TarsCloud/TarsGo/tars/util/current"
	"github.com/TarsCloud/TarsGo/tars/util/tools"
	"unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8
var _ = unsafe.Pointer(nil)

//DataService struct
type DataService struct {
	s m.Servant
}

//HasUser is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) HasUser(wx_id string, userExist *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool((*userExist), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "hasUser", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_bool(&(*userExist), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HasUserWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) HasUserWithContext(tarsCtx context.Context, wx_id string, userExist *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool((*userExist), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "hasUser", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_bool(&(*userExist), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HasUserOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) HasUserOneWayWithContext(tarsCtx context.Context, wx_id string, userExist *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool((*userExist), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "hasUser", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HasPhone is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) HasPhone(phone string, phoneExist *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(phone, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool((*phoneExist), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "hasPhone", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_bool(&(*phoneExist), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HasPhoneWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) HasPhoneWithContext(tarsCtx context.Context, phone string, phoneExist *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(phone, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool((*phoneExist), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "hasPhone", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_bool(&(*phoneExist), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HasPhoneOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) HasPhoneOneWayWithContext(tarsCtx context.Context, phone string, phoneExist *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(phone, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool((*phoneExist), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "hasPhone", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateUser is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateUser(wx_id string, userInfo *UserInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = userInfo.WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createUser", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateUserWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateUserWithContext(tarsCtx context.Context, wx_id string, userInfo *UserInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = userInfo.WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createUser", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateUserOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateUserOneWayWithContext(tarsCtx context.Context, wx_id string, userInfo *UserInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = userInfo.WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "createUser", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetUserInfo is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetUserInfo(wx_id string, userInfo *UserInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = (*userInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getUserInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*userInfo).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetUserInfoWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetUserInfoWithContext(tarsCtx context.Context, wx_id string, userInfo *UserInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = (*userInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getUserInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*userInfo).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetUserInfoOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetUserInfoOneWayWithContext(tarsCtx context.Context, wx_id string, userInfo *UserInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = (*userInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getUserInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGroupInfo is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetGroupInfo(groupInfo *map[int32]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*groupInfo))), 0)
	if err != nil {
		return ret, err
	}

	for k0, v0 := range *groupInfo {

		err = _os.Write_int32(k0, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_string(v0, 1)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getGroupInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 1, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}

	(*groupInfo) = make(map[int32]string)
	for i1, e1 := int32(0), length; i1 < e1; i1++ {
		var k1 int32
		var v1 string

		err = _is.Read_int32(&k1, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_string(&v1, 1, false)
		if err != nil {
			return ret, err
		}

		(*groupInfo)[k1] = v1
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGroupInfoWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetGroupInfoWithContext(tarsCtx context.Context, groupInfo *map[int32]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*groupInfo))), 0)
	if err != nil {
		return ret, err
	}

	for k2, v2 := range *groupInfo {

		err = _os.Write_int32(k2, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_string(v2, 1)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getGroupInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 1, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}

	(*groupInfo) = make(map[int32]string)
	for i3, e3 := int32(0), length; i3 < e3; i3++ {
		var k3 int32
		var v3 string

		err = _is.Read_int32(&k3, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_string(&v3, 1, false)
		if err != nil {
			return ret, err
		}

		(*groupInfo)[k3] = v3
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGroupInfoOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetGroupInfoOneWayWithContext(tarsCtx context.Context, groupInfo *map[int32]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*groupInfo))), 0)
	if err != nil {
		return ret, err
	}

	for k4, v4 := range *groupInfo {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_string(v4, 1)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getGroupInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubManager is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateClubManager(wx_id string, club_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubManagerWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateClubManagerWithContext(tarsCtx context.Context, wx_id string, club_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubManagerOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateClubManagerOneWayWithContext(tarsCtx context.Context, wx_id string, club_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "createClubManager", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClub is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateClub(clubInfo *ClubInfo, club_id *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = clubInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string((*club_id), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*club_id), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateClubWithContext(tarsCtx context.Context, clubInfo *ClubInfo, club_id *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = clubInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string((*club_id), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*club_id), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateClubOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateClubOneWayWithContext(tarsCtx context.Context, clubInfo *ClubInfo, club_id *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = clubInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string((*club_id), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "createClub", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubList is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetClubList(index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {

			err = (*clubInfoList)[i5].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetClubListWithContext(tarsCtx context.Context, index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i6, e6 := int32(0), length; i6 < e6; i6++ {

			err = (*clubInfoList)[i6].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetClubListOneWayWithContext(tarsCtx context.Context, index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetManagerClubList is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetManagerClubList(index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getManagerClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i7, e7 := int32(0), length; i7 < e7; i7++ {

			err = (*clubInfoList)[i7].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetManagerClubListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetManagerClubListWithContext(tarsCtx context.Context, index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getManagerClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*clubInfoList) = make([]ClubInfo, length)
		for i8, e8 := int32(0), length; i8 < e8; i8++ {

			err = (*clubInfoList)[i8].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetManagerClubListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetManagerClubListOneWayWithContext(tarsCtx context.Context, index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*clubInfoList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *clubInfoList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getManagerClubList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubManagerCount is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetClubManagerCount(wx_id string, club_id string, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getClubManagerCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*count), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubManagerCountWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetClubManagerCountWithContext(tarsCtx context.Context, wx_id string, club_id string, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getClubManagerCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*count), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetClubManagerCountOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetClubManagerCountOneWayWithContext(tarsCtx context.Context, wx_id string, club_id string, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getClubManagerCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateApply is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateApply(wx_id string, club_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateApplyWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateApplyWithContext(tarsCtx context.Context, wx_id string, club_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateApplyOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateApplyOneWayWithContext(tarsCtx context.Context, wx_id string, club_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "createApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyListByClubId is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyListByClubId(club_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(club_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getApplyListByClubId", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 5, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i9, e9 := int32(0), length; i9 < e9; i9++ {

			err = (*applyList)[i9].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyListByClubIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyListByClubIdWithContext(tarsCtx context.Context, club_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(club_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getApplyListByClubId", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 5, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i10, e10 := int32(0), length; i10 < e10; i10++ {

			err = (*applyList)[i10].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyListByClubIdOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyListByClubIdOneWayWithContext(tarsCtx context.Context, club_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(club_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getApplyListByClubId", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyListByUserId is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyListByUserId(wx_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getApplyListByUserId", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 5, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i11, e11 := int32(0), length; i11 < e11; i11++ {

			err = (*applyList)[i11].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyListByUserIdWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyListByUserIdWithContext(tarsCtx context.Context, wx_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getApplyListByUserId", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 5, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*applyList) = make([]ApplyInfo, length)
		for i12, e12 := int32(0), length; i12 < e12; i12++ {

			err = (*applyList)[i12].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyListByUserIdOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyListByUserIdOneWayWithContext(tarsCtx context.Context, wx_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*applyList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *applyList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getApplyListByUserId", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetApplyStatus is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) SetApplyStatus(wx_id string, club_id string, apply_status int32, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "setApplyStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 4, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetApplyStatusWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) SetApplyStatusWithContext(tarsCtx context.Context, wx_id string, club_id string, apply_status int32, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "setApplyStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 4, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetApplyStatusOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) SetApplyStatusOneWayWithContext(tarsCtx context.Context, wx_id string, club_id string, apply_status int32, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "setApplyStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyCount is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyCount(wx_id string, club_id string, apply_status int32, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getApplyCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*count), 4, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyCountWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyCountWithContext(tarsCtx context.Context, wx_id string, club_id string, apply_status int32, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getApplyCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*count), 4, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetApplyCountOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetApplyCountOneWayWithContext(tarsCtx context.Context, wx_id string, club_id string, apply_status int32, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(apply_status, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getApplyCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteApply is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteApply(wx_id string, club_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "deleteApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteApplyWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteApplyWithContext(tarsCtx context.Context, wx_id string, club_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "deleteApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteApplyOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteApplyOneWayWithContext(tarsCtx context.Context, wx_id string, club_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "deleteApply", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateActivity(activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateActivityWithContext(tarsCtx context.Context, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateActivityOneWayWithContext(tarsCtx context.Context, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityInfo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "createActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityList is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityList(index int32, batch int32, wx_id string, club_id string, nextIndex *int32, activityList *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*activityList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *activityList {

		err = _os.WriteHead(codec.MAP, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for k13, v13 := range v {

			err = _os.Write_string(k13, 0)
			if err != nil {
				return ret, err
			}

			err = _os.Write_string(v13, 1)
			if err != nil {
				return ret, err
			}

		}
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getActivityList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 5, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*activityList) = make([]map[string]string, length)
		for i14, e14 := int32(0), length; i14 < e14; i14++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}

				(*activityList)[i14] = make(map[string]string)
				for i15, e15 := int32(0), length; i15 < e15; i15++ {
					var k15 string
					var v15 string

					err = _is.Read_string(&k15, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v15, 1, false)
					if err != nil {
						return ret, err
					}

					(*activityList)[i14][k15] = v15
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityListWithContext(tarsCtx context.Context, index int32, batch int32, wx_id string, club_id string, nextIndex *int32, activityList *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*activityList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *activityList {

		err = _os.WriteHead(codec.MAP, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for k16, v16 := range v {

			err = _os.Write_string(k16, 0)
			if err != nil {
				return ret, err
			}

			err = _os.Write_string(v16, 1)
			if err != nil {
				return ret, err
			}

		}
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getActivityList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 5, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*activityList) = make([]map[string]string, length)
		for i17, e17 := int32(0), length; i17 < e17; i17++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}

				(*activityList)[i17] = make(map[string]string)
				for i18, e18 := int32(0), length; i18 < e18; i18++ {
					var k18 string
					var v18 string

					err = _is.Read_string(&k18, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v18, 1, false)
					if err != nil {
						return ret, err
					}

					(*activityList)[i17][k18] = v18
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityListOneWayWithContext(tarsCtx context.Context, index int32, batch int32, wx_id string, club_id string, nextIndex *int32, activityList *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(club_id, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 5)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*activityList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *activityList {

		err = _os.WriteHead(codec.MAP, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for k19, v19 := range v {

			err = _os.Write_string(k19, 0)
			if err != nil {
				return ret, err
			}

			err = _os.Write_string(v19, 1)
			if err != nil {
				return ret, err
			}

		}
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getActivityList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UpdateActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) UpdateActivity(activityIndo *ActivityInfo, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityIndo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "updateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UpdateActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) UpdateActivityWithContext(tarsCtx context.Context, activityIndo *ActivityInfo, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityIndo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "updateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UpdateActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) UpdateActivityOneWayWithContext(tarsCtx context.Context, activityIndo *ActivityInfo, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = activityIndo.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "updateActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivity is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteActivity(activity_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "deleteActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteActivityWithContext(tarsCtx context.Context, activity_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "deleteActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteActivityOneWayWithContext(tarsCtx context.Context, activity_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "deleteActivity", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityInfo is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityInfo(activity_id string, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getActivityInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityInfoWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityInfoWithContext(tarsCtx context.Context, activity_id string, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getActivityInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityInfoOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityInfoOneWayWithContext(tarsCtx context.Context, activity_id string, activityInfo *ActivityInfo, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = (*activityInfo).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getActivityInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityRecord is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateActivityRecord(wx_id string, activity_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createActivityRecord", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityRecordWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateActivityRecordWithContext(tarsCtx context.Context, wx_id string, activity_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "createActivityRecord", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CreateActivityRecordOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) CreateActivityRecordOneWayWithContext(tarsCtx context.Context, wx_id string, activity_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "createActivityRecord", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityRecords is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityRecords(index int32, batch int32, activity_id string, nextIndex *int32, recordList *[]ActivityRecord, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*recordList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *recordList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getActivityRecords", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*recordList) = make([]ActivityRecord, length)
		for i20, e20 := int32(0), length; i20 < e20; i20++ {

			err = (*recordList)[i20].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityRecordsWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityRecordsWithContext(tarsCtx context.Context, index int32, batch int32, activity_id string, nextIndex *int32, recordList *[]ActivityRecord, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*recordList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *recordList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getActivityRecords", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*recordList) = make([]ActivityRecord, length)
		for i21, e21 := int32(0), length; i21 < e21; i21++ {

			err = (*recordList)[i21].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetActivityRecordsOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetActivityRecordsOneWayWithContext(tarsCtx context.Context, index int32, batch int32, activity_id string, nextIndex *int32, recordList *[]ActivityRecord, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(batch, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*recordList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *recordList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getActivityRecords", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetRecordCount is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetRecordCount(wx_id string, activity_id string, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getRecordCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*count), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetRecordCountWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetRecordCountWithContext(tarsCtx context.Context, wx_id string, activity_id string, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getRecordCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*count), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetRecordCountOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetRecordCountOneWayWithContext(tarsCtx context.Context, wx_id string, activity_id string, count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(wx_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(activity_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*count), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getRecordCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityRecord is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteActivityRecord(activity_id string, wx_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "deleteActivityRecord", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityRecordWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteActivityRecordWithContext(tarsCtx context.Context, activity_id string, wx_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "deleteActivityRecord", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*affectRows), 3, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DeleteActivityRecordOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) DeleteActivityRecordOneWayWithContext(tarsCtx context.Context, activity_id string, wx_id string, affectRows *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(activity_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*affectRows), 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "deleteActivityRecord", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//InsertMessage is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) InsertMessage(msg *Message, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = msg.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "insertMessage", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//InsertMessageWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) InsertMessageWithContext(tarsCtx context.Context, msg *Message, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = msg.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "insertMessage", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//InsertMessageOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) InsertMessageOneWayWithContext(tarsCtx context.Context, msg *Message, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = msg.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "insertMessage", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMsgList is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetMsgList(index int32, date string, wx_id string, nextIndex *int32, msgList *[]Message, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(date, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*msgList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *msgList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getMsgList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*msgList) = make([]Message, length)
		for i22, e22 := int32(0), length; i22 < e22; i22++ {

			err = (*msgList)[i22].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMsgListWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetMsgListWithContext(tarsCtx context.Context, index int32, date string, wx_id string, nextIndex *int32, msgList *[]Message, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(date, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*msgList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *msgList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getMsgList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*nextIndex), 4, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		(*msgList) = make([]Message, length)
		for i23, e23 := int32(0), length; i23 < e23; i23++ {

			err = (*msgList)[i23].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMsgListOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetMsgListOneWayWithContext(tarsCtx context.Context, index int32, date string, wx_id string, nextIndex *int32, msgList *[]Message, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_int32(index, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(date, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(wx_id, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*nextIndex), 4)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(len((*msgList))), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *msgList {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}

	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getMsgList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddLike is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) AddLike(message_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(message_id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "addLike", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddLikeWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) AddLikeWithContext(tarsCtx context.Context, message_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(message_id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "addLike", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AddLikeOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) AddLikeOneWayWithContext(tarsCtx context.Context, message_id string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(message_id, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "addLike", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetLike is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetLike(message_id string, like_count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(message_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*like_count), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)
	tarsCtx := context.Background()

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getLike", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*like_count), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetLikeWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetLikeWithContext(tarsCtx context.Context, message_id string, like_count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(message_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*like_count), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 0, "getLike", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&(*like_count), 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetLikeOneWayWithContext is the proxy function for the method defined in the tars file, with the context
func (_obj *DataService) GetLikeOneWayWithContext(tarsCtx context.Context, message_id string, like_count *int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(message_id, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32((*like_count), 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.ResponsePacket)

	err = _obj.s.Tars_invoke(tarsCtx, 1, "getLike", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetServant sets servant for the service.
func (_obj *DataService) SetServant(s m.Servant) {
	_obj.s = s
}

//TarsSetTimeout sets the timeout for the servant which is in ms.
func (_obj *DataService) TarsSetTimeout(t int) {
	_obj.s.TarsSetTimeout(t)
}

//TarsSetProtocol sets the protocol for the servant.
func (_obj *DataService) TarsSetProtocol(p m.Protocol) {
	_obj.s.TarsSetProtocol(p)
}

//AddServant adds servant  for the service.
func (_obj *DataService) AddServant(imp _impDataService, obj string) {
	tars.AddServant(_obj, imp, obj)
}

//AddServant adds servant  for the service with context.
func (_obj *DataService) AddServantWithContext(imp _impDataServiceWithContext, obj string) {
	tars.AddServantWithContext(_obj, imp, obj)
}

type _impDataService interface {
	HasUser(wx_id string, userExist *bool) (ret int32, err error)
	HasPhone(phone string, phoneExist *bool) (ret int32, err error)
	CreateUser(wx_id string, userInfo *UserInfo) (ret int32, err error)
	GetUserInfo(wx_id string, userInfo *UserInfo) (ret int32, err error)
	GetGroupInfo(groupInfo *map[int32]string) (ret int32, err error)
	CreateClubManager(wx_id string, club_id string) (ret int32, err error)
	CreateClub(clubInfo *ClubInfo, club_id *string) (ret int32, err error)
	GetClubList(index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo) (ret int32, err error)
	GetManagerClubList(index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo) (ret int32, err error)
	GetClubManagerCount(wx_id string, club_id string, count *int32) (ret int32, err error)
	CreateApply(wx_id string, club_id string) (ret int32, err error)
	GetApplyListByClubId(club_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	GetApplyListByUserId(wx_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	SetApplyStatus(wx_id string, club_id string, apply_status int32, affectRows *int32) (ret int32, err error)
	GetApplyCount(wx_id string, club_id string, apply_status int32, count *int32) (ret int32, err error)
	DeleteApply(wx_id string, club_id string, affectRows *int32) (ret int32, err error)
	CreateActivity(activityInfo *ActivityInfo) (ret int32, err error)
	GetActivityList(index int32, batch int32, wx_id string, club_id string, nextIndex *int32, activityList *[]map[string]string) (ret int32, err error)
	UpdateActivity(activityIndo *ActivityInfo, affectRows *int32) (ret int32, err error)
	DeleteActivity(activity_id string, affectRows *int32) (ret int32, err error)
	GetActivityInfo(activity_id string, activityInfo *ActivityInfo) (ret int32, err error)
	CreateActivityRecord(wx_id string, activity_id string) (ret int32, err error)
	GetActivityRecords(index int32, batch int32, activity_id string, nextIndex *int32, recordList *[]ActivityRecord) (ret int32, err error)
	GetRecordCount(wx_id string, activity_id string, count *int32) (ret int32, err error)
	DeleteActivityRecord(activity_id string, wx_id string, affectRows *int32) (ret int32, err error)
	InsertMessage(msg *Message) (ret int32, err error)
	GetMsgList(index int32, date string, wx_id string, nextIndex *int32, msgList *[]Message) (ret int32, err error)
	AddLike(message_id string) (ret int32, err error)
	GetLike(message_id string, like_count *int32) (ret int32, err error)
}
type _impDataServiceWithContext interface {
	HasUser(tarsCtx context.Context, wx_id string, userExist *bool) (ret int32, err error)
	HasPhone(tarsCtx context.Context, phone string, phoneExist *bool) (ret int32, err error)
	CreateUser(tarsCtx context.Context, wx_id string, userInfo *UserInfo) (ret int32, err error)
	GetUserInfo(tarsCtx context.Context, wx_id string, userInfo *UserInfo) (ret int32, err error)
	GetGroupInfo(tarsCtx context.Context, groupInfo *map[int32]string) (ret int32, err error)
	CreateClubManager(tarsCtx context.Context, wx_id string, club_id string) (ret int32, err error)
	CreateClub(tarsCtx context.Context, clubInfo *ClubInfo, club_id *string) (ret int32, err error)
	GetClubList(tarsCtx context.Context, index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo) (ret int32, err error)
	GetManagerClubList(tarsCtx context.Context, index int32, batch int32, wx_id string, nextIndex *int32, clubInfoList *[]ClubInfo) (ret int32, err error)
	GetClubManagerCount(tarsCtx context.Context, wx_id string, club_id string, count *int32) (ret int32, err error)
	CreateApply(tarsCtx context.Context, wx_id string, club_id string) (ret int32, err error)
	GetApplyListByClubId(tarsCtx context.Context, club_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	GetApplyListByUserId(tarsCtx context.Context, wx_id string, index int32, batch int32, apply_status int32, nextIndex *int32, applyList *[]ApplyInfo) (ret int32, err error)
	SetApplyStatus(tarsCtx context.Context, wx_id string, club_id string, apply_status int32, affectRows *int32) (ret int32, err error)
	GetApplyCount(tarsCtx context.Context, wx_id string, club_id string, apply_status int32, count *int32) (ret int32, err error)
	DeleteApply(tarsCtx context.Context, wx_id string, club_id string, affectRows *int32) (ret int32, err error)
	CreateActivity(tarsCtx context.Context, activityInfo *ActivityInfo) (ret int32, err error)
	GetActivityList(tarsCtx context.Context, index int32, batch int32, wx_id string, club_id string, nextIndex *int32, activityList *[]map[string]string) (ret int32, err error)
	UpdateActivity(tarsCtx context.Context, activityIndo *ActivityInfo, affectRows *int32) (ret int32, err error)
	DeleteActivity(tarsCtx context.Context, activity_id string, affectRows *int32) (ret int32, err error)
	GetActivityInfo(tarsCtx context.Context, activity_id string, activityInfo *ActivityInfo) (ret int32, err error)
	CreateActivityRecord(tarsCtx context.Context, wx_id string, activity_id string) (ret int32, err error)
	GetActivityRecords(tarsCtx context.Context, index int32, batch int32, activity_id string, nextIndex *int32, recordList *[]ActivityRecord) (ret int32, err error)
	GetRecordCount(tarsCtx context.Context, wx_id string, activity_id string, count *int32) (ret int32, err error)
	DeleteActivityRecord(tarsCtx context.Context, activity_id string, wx_id string, affectRows *int32) (ret int32, err error)
	InsertMessage(tarsCtx context.Context, msg *Message) (ret int32, err error)
	GetMsgList(tarsCtx context.Context, index int32, date string, wx_id string, nextIndex *int32, msgList *[]Message) (ret int32, err error)
	AddLike(tarsCtx context.Context, message_id string) (ret int32, err error)
	GetLike(tarsCtx context.Context, message_id string, like_count *int32) (ret int32, err error)
}

// Dispatch is used to call the server side implemnet for the method defined in the tars file. _withContext shows using context or not.
func (_obj *DataService) Dispatch(tarsCtx context.Context, _val interface{}, tarsReq *requestf.RequestPacket, tarsResp *requestf.ResponsePacket, _withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	_is := codec.NewReader(tools.Int8ToByte(tarsReq.SBuffer))
	_os := codec.NewBuffer()
	switch tarsReq.SFuncName {
	case "hasUser":
		var wx_id string
		var userExist bool

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.HasUser(wx_id, &userExist)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.HasUser(tarsCtx, wx_id, &userExist)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_bool(userExist, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_bool(userExist, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("userExist", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["userExist"] = userExist

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "hasPhone":
		var phone string
		var phoneExist bool

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&phone, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("phone", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&phone, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["phone"])
				if err = json.Unmarshal([]byte(_jsonStr_), &phone); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.HasPhone(phone, &phoneExist)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.HasPhone(tarsCtx, phone, &phoneExist)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_bool(phoneExist, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_bool(phoneExist, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("phoneExist", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["phoneExist"] = phoneExist

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "createUser":
		var wx_id string
		var userInfo UserInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = userInfo.ReadBlock(_is, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("userInfo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = userInfo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["userInfo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &userInfo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.CreateUser(wx_id, &userInfo)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.CreateUser(tarsCtx, wx_id, &userInfo)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getUserInfo":
		var wx_id string
		var userInfo UserInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetUserInfo(wx_id, &userInfo)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetUserInfo(tarsCtx, wx_id, &userInfo)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = userInfo.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = userInfo.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("userInfo", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["userInfo"] = userInfo

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getGroupInfo":
		var groupInfo map[int32]string

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetGroupInfo(&groupInfo)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetGroupInfo(tarsCtx, &groupInfo)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.MAP, 1)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(groupInfo)), 0)
			if err != nil {
				return err
			}

			for k24, v24 := range groupInfo {

				err = _os.Write_int32(k24, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v24, 1)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(groupInfo)), 0)
			if err != nil {
				return err
			}

			for k25, v25 := range groupInfo {

				err = _os.Write_int32(k25, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v25, 1)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("groupInfo", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["groupInfo"] = groupInfo

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "createClubManager":
		var wx_id string
		var club_id string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.CreateClubManager(wx_id, club_id)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.CreateClubManager(tarsCtx, wx_id, club_id)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "createClub":
		var clubInfo ClubInfo
		var club_id string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = clubInfo.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("clubInfo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = clubInfo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["clubInfo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &clubInfo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.CreateClub(&clubInfo, &club_id)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.CreateClub(tarsCtx, &clubInfo, &club_id)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_string(club_id, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_string(club_id, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("club_id", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["club_id"] = club_id

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getClubList":
		var index int32
		var batch int32
		var wx_id string
		var nextIndex int32
		var clubInfoList []ClubInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&batch, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wx_id, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("batch", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&batch, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["batch"])
				if err = json.Unmarshal([]byte(_jsonStr_), &batch); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetClubList(index, batch, wx_id, &nextIndex, &clubInfoList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetClubList(tarsCtx, index, batch, wx_id, &nextIndex, &clubInfoList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("clubInfoList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["clubInfoList"] = clubInfoList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getManagerClubList":
		var index int32
		var batch int32
		var wx_id string
		var nextIndex int32
		var clubInfoList []ClubInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&batch, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wx_id, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("batch", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&batch, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["batch"])
				if err = json.Unmarshal([]byte(_jsonStr_), &batch); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetManagerClubList(index, batch, wx_id, &nextIndex, &clubInfoList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetManagerClubList(tarsCtx, index, batch, wx_id, &nextIndex, &clubInfoList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(clubInfoList)), 0)
			if err != nil {
				return err
			}

			for _, v := range clubInfoList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("clubInfoList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["clubInfoList"] = clubInfoList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getClubManagerCount":
		var wx_id string
		var club_id string
		var count int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetClubManagerCount(wx_id, club_id, &count)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetClubManagerCount(tarsCtx, wx_id, club_id, &count)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(count, 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(count, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("count", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["count"] = count

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "createApply":
		var wx_id string
		var club_id string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.CreateApply(wx_id, club_id)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.CreateApply(tarsCtx, wx_id, club_id)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getApplyListByClubId":
		var club_id string
		var index int32
		var batch int32
		var apply_status int32
		var nextIndex int32
		var applyList []ApplyInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&club_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&index, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&batch, 3, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&apply_status, 4, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("batch", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&batch, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("apply_status", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&apply_status, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["batch"])
				if err = json.Unmarshal([]byte(_jsonStr_), &batch); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["apply_status"])
				if err = json.Unmarshal([]byte(_jsonStr_), &apply_status); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetApplyListByClubId(club_id, index, batch, apply_status, &nextIndex, &applyList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetApplyListByClubId(tarsCtx, club_id, index, batch, apply_status, &nextIndex, &applyList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 5)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 6)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("applyList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["applyList"] = applyList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getApplyListByUserId":
		var wx_id string
		var index int32
		var batch int32
		var apply_status int32
		var nextIndex int32
		var applyList []ApplyInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&index, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&batch, 3, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&apply_status, 4, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("batch", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&batch, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("apply_status", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&apply_status, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["batch"])
				if err = json.Unmarshal([]byte(_jsonStr_), &batch); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["apply_status"])
				if err = json.Unmarshal([]byte(_jsonStr_), &apply_status); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetApplyListByUserId(wx_id, index, batch, apply_status, &nextIndex, &applyList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetApplyListByUserId(tarsCtx, wx_id, index, batch, apply_status, &nextIndex, &applyList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 5)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 6)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(applyList)), 0)
			if err != nil {
				return err
			}

			for _, v := range applyList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("applyList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["applyList"] = applyList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "setApplyStatus":
		var wx_id string
		var club_id string
		var apply_status int32
		var affectRows int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&apply_status, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("apply_status", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&apply_status, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["apply_status"])
				if err = json.Unmarshal([]byte(_jsonStr_), &apply_status); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.SetApplyStatus(wx_id, club_id, apply_status, &affectRows)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.SetApplyStatus(tarsCtx, wx_id, club_id, apply_status, &affectRows)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(affectRows, 4)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(affectRows, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("affectRows", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["affectRows"] = affectRows

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getApplyCount":
		var wx_id string
		var club_id string
		var apply_status int32
		var count int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&apply_status, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("apply_status", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&apply_status, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["apply_status"])
				if err = json.Unmarshal([]byte(_jsonStr_), &apply_status); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetApplyCount(wx_id, club_id, apply_status, &count)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetApplyCount(tarsCtx, wx_id, club_id, apply_status, &count)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(count, 4)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(count, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("count", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["count"] = count

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "deleteApply":
		var wx_id string
		var club_id string
		var affectRows int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.DeleteApply(wx_id, club_id, &affectRows)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.DeleteApply(tarsCtx, wx_id, club_id, &affectRows)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(affectRows, 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(affectRows, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("affectRows", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["affectRows"] = affectRows

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "createActivity":
		var activityInfo ActivityInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = activityInfo.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activityInfo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = activityInfo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityInfo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityInfo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.CreateActivity(&activityInfo)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.CreateActivity(tarsCtx, &activityInfo)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getActivityList":
		var index int32
		var batch int32
		var wx_id string
		var club_id string
		var nextIndex int32
		var activityList []map[string]string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&batch, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wx_id, 3, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&club_id, 4, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("batch", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&batch, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("club_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&club_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["batch"])
				if err = json.Unmarshal([]byte(_jsonStr_), &batch); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["club_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &club_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetActivityList(index, batch, wx_id, club_id, &nextIndex, &activityList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetActivityList(tarsCtx, index, batch, wx_id, club_id, &nextIndex, &activityList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 5)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 6)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(activityList)), 0)
			if err != nil {
				return err
			}

			for _, v := range activityList {

				err = _os.WriteHead(codec.MAP, 0)
				if err != nil {
					return err
				}

				err = _os.Write_int32(int32(len(v)), 0)
				if err != nil {
					return err
				}

				for k26, v26 := range v {

					err = _os.Write_string(k26, 0)
					if err != nil {
						return err
					}

					err = _os.Write_string(v26, 1)
					if err != nil {
						return err
					}

				}
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(activityList)), 0)
			if err != nil {
				return err
			}

			for _, v := range activityList {

				err = _os.WriteHead(codec.MAP, 0)
				if err != nil {
					return err
				}

				err = _os.Write_int32(int32(len(v)), 0)
				if err != nil {
					return err
				}

				for k27, v27 := range v {

					err = _os.Write_string(k27, 0)
					if err != nil {
						return err
					}

					err = _os.Write_string(v27, 1)
					if err != nil {
						return err
					}

				}
			}
			_tupRsp_.PutBuffer("activityList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["activityList"] = activityList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "updateActivity":
		var activityIndo ActivityInfo
		var affectRows int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = activityIndo.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activityIndo", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = activityIndo.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activityIndo"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activityIndo); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.UpdateActivity(&activityIndo, &affectRows)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.UpdateActivity(tarsCtx, &activityIndo, &affectRows)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(affectRows, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(affectRows, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("affectRows", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["affectRows"] = affectRows

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "deleteActivity":
		var activity_id string
		var affectRows int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&activity_id, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activity_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activity_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activity_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activity_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.DeleteActivity(activity_id, &affectRows)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.DeleteActivity(tarsCtx, activity_id, &affectRows)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(affectRows, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(affectRows, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("affectRows", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["affectRows"] = affectRows

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getActivityInfo":
		var activity_id string
		var activityInfo ActivityInfo

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&activity_id, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activity_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activity_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activity_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activity_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetActivityInfo(activity_id, &activityInfo)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetActivityInfo(tarsCtx, activity_id, &activityInfo)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = activityInfo.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = activityInfo.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("activityInfo", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["activityInfo"] = activityInfo

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "createActivityRecord":
		var wx_id string
		var activity_id string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&activity_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("activity_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activity_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activity_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activity_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.CreateActivityRecord(wx_id, activity_id)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.CreateActivityRecord(tarsCtx, wx_id, activity_id)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getActivityRecords":
		var index int32
		var batch int32
		var activity_id string
		var nextIndex int32
		var recordList []ActivityRecord

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&batch, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&activity_id, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("batch", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&batch, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("activity_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activity_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["batch"])
				if err = json.Unmarshal([]byte(_jsonStr_), &batch); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activity_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activity_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetActivityRecords(index, batch, activity_id, &nextIndex, &recordList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetActivityRecords(tarsCtx, index, batch, activity_id, &nextIndex, &recordList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(recordList)), 0)
			if err != nil {
				return err
			}

			for _, v := range recordList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(recordList)), 0)
			if err != nil {
				return err
			}

			for _, v := range recordList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("recordList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["recordList"] = recordList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getRecordCount":
		var wx_id string
		var activity_id string
		var count int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&wx_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&activity_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("activity_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activity_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activity_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activity_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetRecordCount(wx_id, activity_id, &count)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetRecordCount(tarsCtx, wx_id, activity_id, &count)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(count, 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(count, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("count", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["count"] = count

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "deleteActivityRecord":
		var activity_id string
		var wx_id string
		var affectRows int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&activity_id, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wx_id, 2, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("activity_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&activity_id, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["activity_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &activity_id); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.DeleteActivityRecord(activity_id, wx_id, &affectRows)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.DeleteActivityRecord(tarsCtx, activity_id, wx_id, &affectRows)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(affectRows, 3)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(affectRows, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("affectRows", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["affectRows"] = affectRows

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "insertMessage":
		var msg Message

		if tarsReq.IVersion == basef.TARSVERSION {

			err = msg.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("msg", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = msg.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["msg"])
				if err = json.Unmarshal([]byte(_jsonStr_), &msg); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.InsertMessage(&msg)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.InsertMessage(tarsCtx, &msg)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getMsgList":
		var index int32
		var date string
		var wx_id string
		var nextIndex int32
		var msgList []Message

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_int32(&index, 1, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&date, 2, true)
			if err != nil {
				return err
			}

			err = _is.Read_string(&wx_id, 3, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("index", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_int32(&index, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("date", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&date, 0, true)
			if err != nil {
				return err
			}

			_reqTup_.GetBuffer("wx_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&wx_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["index"])
				if err = json.Unmarshal([]byte(_jsonStr_), &index); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["date"])
				if err = json.Unmarshal([]byte(_jsonStr_), &date); err != nil {
					return err
				}
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["wx_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &wx_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetMsgList(index, date, wx_id, &nextIndex, &msgList)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetMsgList(tarsCtx, index, date, wx_id, &nextIndex, &msgList)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(nextIndex, 4)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 5)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(msgList)), 0)
			if err != nil {
				return err
			}

			for _, v := range msgList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(nextIndex, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("nextIndex", _os.ToBytes())

			_os.Reset()
			err = _os.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(msgList)), 0)
			if err != nil {
				return err
			}

			for _, v := range msgList {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
			_tupRsp_.PutBuffer("msgList", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["nextIndex"] = nextIndex
			_rspJson_["msgList"] = msgList

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "addLike":
		var message_id string

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&message_id, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("message_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&message_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["message_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &message_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.AddLike(message_id)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.AddLike(tarsCtx, message_id)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}
	case "getLike":
		var message_id string
		var like_count int32

		if tarsReq.IVersion == basef.TARSVERSION {

			err = _is.Read_string(&message_id, 1, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_reqTup_ := tup.NewUniAttribute()
			_reqTup_.Decode(_is)

			var _tupBuffer_ []byte

			_reqTup_.GetBuffer("message_id", &_tupBuffer_)
			_is.Reset(_tupBuffer_)
			err = _is.Read_string(&message_id, 0, true)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			err = json.Unmarshal(_is.ToBytes(), &_jsonDat_)
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["message_id"])
				if err = json.Unmarshal([]byte(_jsonStr_), &message_id); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version:", tarsReq.IVersion)
			return err
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impDataService)
			_funRet_, err = _imp.GetLike(message_id, &like_count)
		} else {
			_imp := _val.(_impDataServiceWithContext)
			_funRet_, err = _imp.GetLike(tarsCtx, message_id, &like_count)
		}

		if err != nil {
			return err
		}

		if tarsReq.IVersion == basef.TARSVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(like_count, 2)
			if err != nil {
				return err
			}

		} else if tarsReq.IVersion == basef.TUPVERSION {
			_tupRsp_ := tup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("", _os.ToBytes())
			_tupRsp_.PutBuffer("tars_ret", _os.ToBytes())

			_os.Reset()
			err = _os.Write_int32(like_count, 0)
			if err != nil {
				return err
			}

			_tupRsp_.PutBuffer("like_count", _os.ToBytes())

			_os.Reset()
			err = _tupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tarsReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["tars_ret"] = _funRet_
			_rspJson_["like_count"] = like_count

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var _status map[string]string
	s, ok := current.GetResponseStatus(tarsCtx)
	if ok && s != nil {
		_status = s
	}
	var _context map[string]string
	c, ok := current.GetResponseContext(tarsCtx)
	if ok && c != nil {
		_context = c
	}
	*tarsResp = requestf.ResponsePacket{
		IVersion:     tarsReq.IVersion,
		CPacketType:  0,
		IRequestId:   tarsReq.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(_os.ToBytes()),
		Status:       _status,
		SResultDesc:  "",
		Context:      _context,
	}

	_ = _is
	_ = _os
	_ = length
	_ = have
	_ = ty
	return nil
}
